[
  {
    "id": 0,
    "imgUrl": "/public/images/2018/02/0000.png",
    "knowledgeLevel": 0,
    "section": "0",
    "sectionHeading": "About This Guide",
    "syllabusText": "'Certified Tester Foundation Level Syllabus' quote will display here © ISTQB. Incorporated society",
    "fostSynopsis": "'Foundations of Software Testing' quote will display here © Cengage Learning EMEA",
    "aostSynopsis": "'The Art of Software Testing' quote will display here © Word Association, Inc."
  },
  {
    "id": 1,
    "imgUrl": "/public/images/2018/02/slide-0001-white.png",
    "knowledgeLevel": 2,
    "section": "1",
    "sectionHeading": "Fundamentals of Testing",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 2,
    "imgUrl": "/public/images/2018/02/slide-0002-white.png",
    "knowledgeLevel": 2,
    "section": "1.1",
    "sectionHeading": "Why is Testing Necessary",
    "syllabusText": "Terms: bug, defect, error, failure, fault, mistake, quality, risk",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 3,
    "imgUrl": "/public/images/2018/02/slide-0003-white.png",
    "knowledgeLevel": 1,
    "section": "1.1.1",
    "sectionHeading": "Software Systems Context",
    "syllabusText": "Software systems are an integral part of life, from business applications (e.g., banking) to consumer products (e.g., cars). Most people have had an experience with software that did not work as expected. Software that does not work correctly can lead to many problems, including loss of money, time or business reputation, and could even cause injury or death.",
    "fostSynopsis": "Almost every living person has been touched by information technology, and most of us have dealt with the frustration and wasted time that occurs when software fails and exhibits unexpected behaviours. Some unfortunate individuals and companies have experienced financial loss or damage to their personal or business reputations as a result of defective software. (p.2)",
    "aostSynopsis": "Therefore, the software we write today potentially touches millions of people, either enabling them to do their jobs effectively and efficiently, or causing them untold frustration and costing them in the form of lost work or lost business. (p1)"
  },
  {
    "id": 4,
    "imgUrl": "/public/images/2018/02/slide-0004-white.png",
    "knowledgeLevel": 2,
    "section": "1.1.2",
    "sectionHeading": "Causes of Software Defects",
    "syllabusText": "Defects occur because human beings are fallible and because there is time pressure, complex code, complexity of infrastructure, changing technologies, and/or many system interactions. Failures can be caused by environmental conditions as well. For example, radiation, magnetism, electronic fields, and pollution can cause faults in firmware or influence the execution of software by changing the hardware conditions.",
    "fostSynopsis": "So, human beings are fallible and thus, when they work, they sometimes introduce defects. ...  In some cases, environmental conditions can lead to unexpected results\nthat do not relate to a software defect. (p.2-3)",
    "aostSynopsis": ""
  },
  {
    "id": 5,
    "imgUrl": "/public/images/2018/02/slide-0005-white.png",
    "knowledgeLevel": 2,
    "section": "1.1.3",
    "sectionHeading": "Role of Testing in Software Development, Maintenance and Operations ",
    "syllabusText": "Rigorous testing of systems and documentation can help to reduce the risk of problems occurring during operation and contribute to the quality of the software system, if the defects found are corrected before the system is released for operational use.Software testing may also be required to meet contractual or legal requirements, or industry-specific standards.",
    "fostSynopsis": "While nothing can reduce the level of risk to zero, we certainly can – and should – try to reduce risk to an acceptable level prior to releasing the software to customers and users. (p4)",
    "aostSynopsis": ""
  },
  {
    "id": 6,
    "imgUrl": "/public/images/2018/02/slide-0006-white.png",
    "knowledgeLevel": 2,
    "section": "1.1.4",
    "sectionHeading": "Testing and Quality ",
    "syllabusText": "Testing can give confidence in the quality of the software if it finds few or no defects. A properly designed test that passes reduces the overall level of risk in a system. When testing does find defects, the quality of the software system increases when those defects are fixed. Lessons should be learned from previous projects. By understanding the root causes of defects found in other projects, processes can be improved, which in turn should prevent those defects from reoccurring and, as a consequence, improve the quality of future systems. This is an aspect of quality assurance.",
    "fostSynopsis": "When a properly designed test is run, an unknown situation is changed into a known situation, which reduces the level of risk to the quality of the product. ... Testing also provides a learning opportunity that allows for improved quality if lessons are learned from each project. If root cause analysis is carried out for the defects found on each project, the team can improve its software development processes to avoid the introduction of similar defects in future systems. (p5)",
    "aostSynopsis": "Testing is the process of executing a program with the intent of finding errors. (p.6)"
  },
  {
    "id": 7,
    "imgUrl": "/public/images/2018/02/slide-0007-white.png",
    "knowledgeLevel": 2,
    "section": "1.1.5",
    "sectionHeading": "How Much Testing is Enough?",
    "syllabusText": "Deciding how much testing is enough should take account of the level of risk, including technical, safety, and business risks, and project constraints such as time and budget. Testing should provide sufficient information to stakeholders to make informed decisions about the release of the software or system being tested, for the next development step or handover to customers.",
    "fostSynopsis": "We could say that sufficient coverage is achieved when we balance what we should cover against project constraints such as time and budget. We should also ensure that testing provides sufficient information to the project and product stakeholders, so that they can decide whether to proceed with the project or with release. (p.5-6)",
    "aostSynopsis": "The best way to establish some confidence in this claim is to try to refute it, that is, to try to find imperfections rather than just confirm that the program works correctly for some set of input data. (p.8)"
  },
  {
    "id": 8,
    "imgUrl": "/public/images/2018/02/slide-0008-white.png",
    "knowledgeLevel": 2,
    "section": "1.2",
    "sectionHeading": "What is Testing?",
    "syllabusText": "Test activities exist before and after test execution. These activities include planning and control, choosing test conditions, designing and executing test cases, checking results, evaluating exit criteria, reporting on the testing process and system under test, and finalizing or completing closure activities after a test phase has been completed. Testing also includes reviewing documents (including source code) and conducting static analysis.",
    "fostSynopsis": "The process consisting of all lifecycle activities, both static and dynamic, concerned with planning, preparation and evaluation of software products and related work products to determine that they satisfy specified requirements, to demonstrate that they are fit for purpose and to detect defects. (p. 8)",
    "aostSynopsis": "Testing is the process of executing a program with the intent of finding errors. (p. 6)"
  },
  {
    "id": 9,
    "imgUrl": "/public/images/2018/02/slide-0009-white.png",
    "knowledgeLevel": 2,
    "section": "1.3",
    "sectionHeading": "Seven Testing Principles",
    "syllabusText": "1 – Testing shows presence of defects. 2 – Exhaustive testing is impossible. 3 – Early testing. 4 – Defect clustering. 5 – Pesticide paradox. 6 – Testing is context dependent. 7 – Absence-of-errors fallacy.",
    "fostSynopsis": "These principles, while not always understood or noticed, are in action on most if not all projects. Knowing how to spot these principles, and how to take advantage of them, will make you a better tester. (p. 9)",
    "aostSynopsis": "1 - A necessary part of a test case is a definition of the expected output or result. 2 - A programmer should avoid attempting to test his or her own program. 3 - A programming organization should not test its own programs. 4 - Any testing process should include a thorough inspection of the results of each test. 5 - Test cases must be written for input conditions that are invalid and unexpected, as well as for those that are valid and expected. 6 - Examining a program to see if it does not do what it is supposed to do is only half the battle; the other half is seeing whether the program does what it is not supposed to do. 7 - Avoid throwaway test cases unless the program is truly a throwaway program. 8 - Do not plan a testing effort under the tacit assumption that no errors will be found. 9 - The probability of the existence of more errors in a section of a program is proportional to the number of errors already found in that section. 10 - Testing is an extremely creative and intellectually challenging task. (p. 13)"
  },
  {
    "id": 10,
    "imgUrl": "/public/images/2018/02/slide-0010-white.png",
    "knowledgeLevel": 1,
    "section": "1.4",
    "sectionHeading": "Fundamental Test Process",
    "syllabusText": "Terms: Confirmation testing, re-testing, exit criteria, incident, regression testing, test basis, test condition, test coverage, test data, test execution, test log, test plan, test procedure, test policy, test suite, test summary report, testware",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 11,
    "imgUrl": "/public/images/2018/02/slide-0011-white.png",
    "knowledgeLevel": 1,
    "section": "1.4.1",
    "sectionHeading": "Test Planning and Control",
    "syllabusText": "Test planning is the activity of defining the objectives of testing and the specification of test activities in order to meet the objectives and mission. Test control is the ongoing activity of comparing actual progress against the plan, and reporting the status, including deviations from the plan. It involves taking actions necessary to meet the mission and objectives of the project. In order to control testing, the testing activities should be monitored throughout the project. Test planning takes into account the feedback from monitoring and control activities.",
    "fostSynopsis": "...planning involves defining the overall strategic and tactical objectives of testing, as well as discovering and specifying the specific test activities required to satisfy those objectives and the general mission of testing. ... in test control we continuously compare actual progress against the plan, adjust the plan, report the test status and any necessary deviations from the plan, monitor test activities, and take whatever actions are necessary to meet the mission and objectives of the project. (p.15)",
    "aostSynopsis": "... the major mistake most often made in planning a testing process is the tacit assumption that no errors will be found. The obvious result of this mistake is that the planned resources (people, calendar time, and computer time) will be grossly underestimated, a notorious problem in the computing industry. Compounding the problem is the fact that the testing process falls at the end of the development cycle, meaning that resource changes are difficult. A second, perhaps more insidious problem is that the wrong definition of testing is being used, since it is difficult to see how someone using the correct definition of testing (the goal being to find errors) would plan a test using the assumption that no errors will be found. (p. 133)"
  },
  {
    "id": 12,
    "imgUrl": "/public/images/2018/02/slide-0012-white.png",
    "knowledgeLevel": 1,
    "section": "1.4.2",
    "sectionHeading": "Test Analysis and Design",
    "syllabusText": "Test analysis and design is the activity during which general testing objectives are transformed into tangible test conditions and test cases.",
    "fostSynopsis": "In test analysis and design, we transform the more general testing objectives defined in the test plan into tangible test conditions and test cases. The way in which and degree to which the test conditions and test cases are made tangible – that is to say, specifically documented – depends on the needs of the testers, the expectations of the project team, any applicable regulations, and other considerations. (p. 15)",
    "aostSynopsis": "What subset of all possible test cases has the highest probability of detecting the most errors? (p.41)"
  },
  {
    "id": 13,
    "imgUrl": "/public/images/2018/02/slide-0013-white.png",
    "knowledgeLevel": 1,
    "section": "1.4.3",
    "sectionHeading": "Test Implementation and Execution",
    "syllabusText": "Test implementation and execution is the activity where test procedures or scripts are specified by combining the test cases in a particular order and including any other information needed for test execution, the environment is set up and the tests are run.",
    "fostSynopsis": "In test implementation and execution, we specify test procedures (or test scripts). This involves combining the test cases in a particular order, as well as including any other information needed for test execution. This involves transforming the high level (or abstract or logical) test cases into low level (concrete) test cases, which may be done more formally and written into a test script, or it may be done 'on the fly' as a tester is executing tests from a list of high level test conditions. Test implementation also involves setting up the test environment. During test execution, of course, we run the tests. (p.16)",
    "aostSynopsis": "Once you have agreed that aggressive software testing is a worthy addition to your development efforts, the next step is to design test cases that will exercise your application sufficiently to produce satisfactory test results. In most cases, consider a combination of black-box and white-box methodologies to ensure that you have designed rigorous program testing. (p. 83)"
  },
  {
    "id": 14,
    "imgUrl": "/public/images/2018/02/slide-0014-white.png",
    "knowledgeLevel": 1,
    "section": "1.4.4",
    "sectionHeading": "Evaluating Exit Criteria and Reporting",
    "syllabusText": "Evaluating exit criteria is the activity where test execution is assessed against the defined objectives.",
    "fostSynopsis": "The set of generic and specific conditions, agreed upon with the stakeholders, for permitting a process to be officially completed. The purpose of exit criteria is to prevent a task from being considered completed when there are still outstanding parts of the task which have not been finished. Exit criteria are used to report against and to plan when to stop testing. (p. 17)",
    "aostSynopsis": "One of the most difficult questions to answer when testing a program is determining when to stop, since there is no way of knowing if the error just detected is the last remaining error. In fact, in anything but a small program, it is unreasonable to expect that all errors will eventually be detected. Given this dilemma, and given the fact that economics dictate that testing must eventually terminate. (p. 135)"
  },
  {
    "id": 15,
    "imgUrl": "/public/images/2018/02/slide-0015-white.png",
    "knowledgeLevel": 1,
    "section": "1.4.5",
    "sectionHeading": "Test Closure Activities",
    "syllabusText": "Test closure activities collect data from completed test activities to consolidate experience, testware, facts and numbers. Test closure activities occur at project milestones such as when a software system is released, a test project is completed (or cancelled), a milestone has been achieved, or a maintenance release has been completed.",
    "fostSynopsis": "In test closure, we collect data from completed test activities to consolidate experience, testware, facts and numbers. Test closure activities should occur at major project milestones. These can include when a software system is released, a test project is completed (or cancelled), a milestone has been achieved, or a maintenance release has been completed, though the specific milestones that involve closure activities should be specified in the test plan. (p. 18)",
    "aostSynopsis": ""
  },
  {
    "id": 16,
    "imgUrl": "/public/images/2018/02/slide-0016-white.png",
    "knowledgeLevel": 2,
    "section": "The Psychology of Testing",
    "sectionHeading": "1.5",
    "syllabusText": "The mindset to be used while testing and reviewing is different from that used while developing software. With the right mindset developers are able to test their own code, but separation of this responsibility to a tester is typically done to help focus effort and provide additional benefits, such as an independent view by trained and professional testing resources. Independent testing may be carried out at any level of testing.",
    "fostSynopsis": "... clear objectives for testing, the proper roles and balance of self-testing and independent testing, clear, courteous communication and feedback on defects. ... The softer side of software testing is often the harder side to master. A tester may have adequate or even excellent technique skills and certifications, but if they do not have adequate interpersonal and communication skills, they will not be an effective tester. Such soft skills can be improved with training and practice. (p. 18-23)",
    "aostSynopsis": "Software testing is a technical task, yes, but it also involves some important considerations of economics and human psychology (p. 5)"
  },
  {
    "id": 17,
    "imgUrl": "/public/images/2018/02/slide-0017-white.png",
    "knowledgeLevel": 2,
    "section": "Code of Ethics",
    "sectionHeading": "1.6",
    "syllabusText": "Involvement in software testing enables individuals to learn confidential and privileged information. A code of ethics is necessary, among other reasons to ensure that the information is not put to inappropriate use.",
    "fostSynopsis": "As a software tester, as in any other profession, you will from time to time encounter ethical challenges. On the one hand, you are likely to have access to confidential and privileged information, or to be in the position to harm someone’s interests. On the other hand, you are likely to have opportunities to advance good causes. So, a code of ethics will help guide your decisions and choose the best possible outcome. (p. 23)",
    "aostSynopsis": ""
  },
  {
    "id": 18,
    "imgUrl": "/public/images/2018/05/slide-0018-white.png",
    "knowledgeLevel": 2,
    "section": "2",
    "sectionHeading": "Testing Throughout the Software Life Cycle",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 19,
    "imgUrl": "/public/images/2018/05/slide-0019-white.png",
    "knowledgeLevel": 2,
    "section": "2.1",
    "sectionHeading": "Software Development Models",
    "syllabusText": "Testing does not exist in isolation; test activities are related to software development activities. Different development life cycle models need different approaches to testing.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 20,
    "imgUrl": "/public/images/2018/05/slide-0020-white.png",
    "knowledgeLevel": 2,
    "section": "2.1.1",
    "sectionHeading": "V-model (Sequential Development Model)",
    "syllabusText": "Although variants of the V-model exist, a common type of V-model uses four test levels, corresponding to the four development levels. 1 - Component (unit) testing. 2 - Integration testing. 3 - System testing. 4 - Acceptance testing.",
    "fostSynopsis": "The V-model is a model that illustrates how testing activities (verification and validation) can be integrated into each phase of the life cycle. Within the V-model, validation testing takes place especially during the early stages, e.g. reviewing the user requirements, and late in the life cycle, e.g. during user acceptance testing. (p. 29)",
    "aostSynopsis": ""
  },
  {
    "id": 21,
    "imgUrl": "/public/images/2018/05/slide-0021-white.png",
    "knowledgeLevel": 2,
    "section": "2.1.2",
    "sectionHeading": "Iterative-incremental Development Models",
    "syllabusText": "Iterative-incremental development is the process of establishing requirements, desinging, building and testing a system in a series of short development cycles.",
    "fostSynopsis": "Subsequent increments will need testing for the new functionality, regression testing of the existing functionality, and integration testing of both new and existing parts. Regression testing is increasingly important on all iterations after the first one. (p. 30-31)",
    "aostSynopsis": ""
  },
  {
    "id": 22,
    "imgUrl": "/public/images/2018/05/slide-0022-white.png",
    "knowledgeLevel": 2,
    "section": "2.1.3",
    "sectionHeading": "Testing within a Life Cycle Model",
    "syllabusText": "Test levels can be combined or reorganized depending on the nature of the project or the system architecure.",
    "fostSynopsis": "There are several characteristics of good testing: 1 - For every development activity there is a corresponding testing activity. 2 - Each test level has test objectives specific to that level. 3 - The analysis and design of tests for a given test level should begin during the corresponding development activity. 4- Testers should be involved in reviewing documents as soon as drafts are available in the development cycle. (p. 34)",
    "aostSynopsis": ""
  },
  {
    "id": 23,
    "imgUrl": "/public/images/2018/05/slide-0023-white.png",
    "knowledgeLevel": 2,
    "section": "2.2",
    "sectionHeading": "Test Levels",
    "syllabusText": "For each of the test levels, the following can be identified: the generic objectives, the work product(s) being referenced for deriving test cases (i.e., the test basis), the test object (i.e., what is being tested), typical defects and failures to be found, test harness requirements and tool support, and specific approaches and responsibilities.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 24,
    "imgUrl": "/public/images/2018/05/slide-0024-white.png",
    "knowledgeLevel": 2,
    "section": "2.2.1",
    "sectionHeading": "Component Testing",
    "syllabusText": "Component testing (also known as unit, module or program testing) searches for defects in, and verifies the functioning of, software modules, programs, objects, classes, etc., that are separately testable. It may be done in isolation from the rest of the system, depending on the context of the development life cycle and the system. Stubs, drivers and simulators may be used.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 25,
    "imgUrl": "/public/images/2018/05/slide-0025-white.png",
    "knowledgeLevel": 2,
    "section": "2.2.2",
    "sectionHeading": "Integration Testing",
    "syllabusText": "Integration testing tests interfaces between components, interactions with different parts of a system, such as the operating system, file system and hardware, and interfaces between systems.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 26,
    "imgUrl": "/public/images/2018/05/slide-0026-white.png",
    "knowledgeLevel": 2,
    "section": "2.2.3",
    "sectionHeading": "System Testing",
    "syllabusText": "System testing is concerned with the behavior of a whole system/product. The testing scope shall be clearly addressed in the Master and/or Level Test Plan for that test level.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 27,
    "imgUrl": "/public/images/2018/05/slide-0027-white.png",
    "knowledgeLevel": 2,
    "section": "2.2.4",
    "sectionHeading": "Acceptance Testing",
    "syllabusText": "Acceptance testing is often the responsibility of the customers or users of a system; other stakeholders may be involved as well.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 28,
    "imgUrl": "/public/images/2018/05/slide-0028-white.png",
    "knowledgeLevel": 2,
    "section": "2.3",
    "sectionHeading": "Test Types",
    "syllabusText": "A group of test activities can be aimed at verifying the software system (or a part of a system) based on a specific reason or target for testing.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 29,
    "imgUrl": "/public/images/2018/05/slide-0029-white.png",
    "knowledgeLevel": 2,
    "section": "2.3.1",
    "sectionHeading": "Testing of Function (Functional Testing)",
    "syllabusText": "Functional tests are based on functions and features (described in documents or understood by the testers) and their interoperability with specific systems, and may be performed at all test levels (e.g., tests for components may be based on a component specification).",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 30,
    "imgUrl": "/public/images/2018/05/slide-0030-white.png",
    "knowledgeLevel": 2,
    "section": "2.3.2",
    "sectionHeading": "Testing of Non-functional Software Characteristics (Non-functional Testing)",
    "syllabusText": "The term non-functional testing describes the tests required to measure characteristics of systems and software that can be quantified on a varying scale, such as response times for performance testing.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 31,
    "imgUrl": "/public/images/2018/05/slide-0031-white.png",
    "knowledgeLevel": 2,
    "section": "2.3.3",
    "sectionHeading": "Testing of Software/Architecture (Structural Testing)",
    "syllabusText": "Structural (white-box) testing may be performed at all test levels. Structural techniques are best used after specification-based techniques, in order to help measure the thoroughness of testing through assessment of coverage of a type of structure.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 32,
    "imgUrl": "/public/images/2018/05/slide-0032-white.png",
    "knowledgeLevel": 2,
    "section": "2.3.4",
    "sectionHeading": "Testing Related to Changes: Re-testing and Regression Testing",
    "syllabusText": "Regression testing is the repeated testing of an already tested program, after modification, to discover any defects introduced or uncovered as a result of the change(s). These defects may be either in the software being tested, or in another related or unrelated software component. It is performed when the software, or its environment, is changed. The extent of regression testing is based on the risk of not finding defects in software that was working previously.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 33,
    "imgUrl": "/public/images/2018/05/slide-0033-white.png",
    "knowledgeLevel": 2,
    "section": "2.4",
    "sectionHeading": "Maintenance Testing",
    "syllabusText": "Once deployed, a software system is often in service for years or decades. During this time the system, its configuration data, or its environment are often corrected, changed or extended. The planning of releases in advance is crucial for successful maintenance testing. A distinction has to be made between planned releases and hot fixes. Maintenance testing is done on an existing operational system, and is triggered by modifications, migration, or retirement of the software or system.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 34,
    "imgUrl": "/public/images/2018/05/slide-0034-white.png",
    "knowledgeLevel": 2,
    "section": "3",
    "sectionHeading": "Static Techniques",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 35,
    "imgUrl": "/public/images/2018/05/slide-0035-white.png",
    "knowledgeLevel": 2,
    "section": "3.1",
    "sectionHeading": "Static Techniques and Test Process",
    "syllabusText": "Unlike dynamic testing, which requires the execution of software, static testing techniques rely on the manual examination (reviews) and automated analysis (static analysis) of the code or other project documentation without the execution of the code.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 36,
    "imgUrl": "/public/images/2018/05/slide-0036-white.png",
    "knowledgeLevel": 2,
    "section": "3.2",
    "sectionHeading": "Review Process",
    "syllabusText": "The different types of reviews vary from informal, characterized by no written instructions for reviewers, to systematic, characterized by team participation, documented results of the review, and documented procedures for conducting the review.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 37,
    "imgUrl": "/public/images/2018/05/slide-0037-white.png",
    "knowledgeLevel": 1,
    "section": "3.2.1",
    "sectionHeading": "Activities of a Foraml Review",
    "syllabusText": "A typical formal review has the following main activities: 1 - Planning. 2 - Kick-off. 3 - Individual preparation. 4 - Examination of Results. 5 - Rework. 6 - Follow-up.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 38,
    "imgUrl": "/public/images/2018/05/slide-0038-white.png",
    "knowledgeLevel": 1,
    "section": "3.2.2",
    "sectionHeading": "Roles and Responsibilites",
    "syllabusText": "Looking at software products or related work products from different perspectives and using checklists can make reviews more effective and efficient. For example, a checklist based on various perspectives such as user, maintainer, tester or operations, or a checklist of typical requirements problems may help to uncover previously undetected issues.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 39,
    "imgUrl": "/public/images/2018/05/slide-0039-white.png",
    "knowledgeLevel": 2,
    "section": "3.2.3",
    "sectionHeading": "Types of Reviews",
    "syllabusText": "A single software product or related work product may be the subject of more than one review. If more than one type of review is used, the order may vary. For example, an informal review may be carried out before a technical review, or an inspection may be carried out on a requirements specification before a walkthrough with customers",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 40,
    "imgUrl": "/public/images/2018/05/slide-0040-white.png",
    "knowledgeLevel": 2,
    "section": "3.2.4",
    "sectionHeading": "Success Factors for Reviews",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 41,
    "imgUrl": "/public/images/2018/05/slide-0041-white.png",
    "knowledgeLevel": 2,
    "section": "3.3",
    "sectionHeading": "Static Analysis by Tools",
    "syllabusText": "The objective of static analysis is to find defects in software source code and software models. Static analysis is performed without actually executing the software being examined by the tool; dynamic testing does execute the software code. Static analysis can locate defects that are hard to find in dynamic testing. As with reviews, static analysis finds defects rather than failures. Static analysis tools analyze program code (e.g., control flow and data flow), as well as generated output such as HTML and XML.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 42,
    "imgUrl": "/public/images/2018/05/slide-0042-white.png",
    "knowledgeLevel": 4,
    "section": "4",
    "sectionHeading": "Test Design Techniques",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 43,
    "imgUrl": "/public/images/2018/05/slide-0043-white.png",
    "knowledgeLevel": 3,
    "section": "4.1",
    "sectionHeading": "The Test Development Process",
    "syllabusText": "The test development process described in this section can be done in different ways, from very informal with little or no documentation, to very formal (as it is described below). The level of formality depends on the context of the testing, including the maturity of testing and development processes, time constraints, safety or regulatory requirements, and the people involved.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 44,
    "imgUrl": "/public/images/2018/05/slide-0044-white.png",
    "knowledgeLevel": 2,
    "section": "4.2",
    "sectionHeading": "Categories of Test Design Techniques",
    "syllabusText": "The purpose of a test design technique is to identify test conditions, test cases, and test data.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 45,
    "imgUrl": "/public/images/2018/05/slide-0045-white.png",
    "knowledgeLevel": 3,
    "section": "4.3",
    "sectionHeading": "Specification-based or Black-box Techniques",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 46,
    "imgUrl": "/public/images/2018/05/slide-0046-white.png",
    "knowledgeLevel": 3,
    "section": "4.3.1",
    "sectionHeading": "Equivalence Partioning",
    "syllabusText": "In equivalence partitioning, inputs to the software or system are divided into groups that are expected to exhibit similar behavior, so they are likely to be processed in the same way.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 47,
    "imgUrl": "/public/images/2018/05/slide-0047-white.png",
    "knowledgeLevel": 3,
    "section": "4.3.2",
    "sectionHeading": "Boundry Value Analysis",
    "syllabusText": "The maximum and minimum values of a partition are its boundary values. A boundary value for a valid partition is a valid boundary value; the boundary of an invalid partition is an invalid boundary value.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 48,
    "imgUrl": "/public/images/2018/05/slide-0048-white.png",
    "knowledgeLevel": 3,
    "section": "4.3.3",
    "sectionHeading": "Decision Table Testing",
    "syllabusText": "Decision tables are a good way to capture system requirements that contain logical conditions, and to document internal system design. They may be used to record complex business rules that a system is to implement.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 49,
    "imgUrl": "/public/images/2018/05/slide-0049-white.png",
    "knowledgeLevel": 3,
    "section": "4.3.4",
    "sectionHeading": "State Transition Testing",
    "syllabusText": "A system may exhibit a different response depending on current conditions or previous history (its state). In this case, that aspect of the system can be shown with a state transition diagram. It allows the tester to view the software in terms of its states, transitions between states, the inputs or events that trigger state changes (transitions) and the actions which may result from those transitions. The states of the system or object under test are separate, identifiable and finite in number.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 50,
    "imgUrl": "/public/images/2018/05/slide-0050-white.png",
    "knowledgeLevel": 2,
    "section": "4.3.5",
    "sectionHeading": "Use Case Testing",
    "syllabusText": "A use case describes interactions between actors (users or systems), which produce a result of value to a system user or the customer. Use cases may be described at the abstract level (business use case, technology-free, business process level) or at the system level (system use case on the system functionality level).",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 51,
    "imgUrl": "/public/images/2018/05/slide-0051-white.png",
    "knowledgeLevel": 4,
    "section": "4.4",
    "sectionHeading": "Structure-based or White-box Techniques",
    "syllabusText": "Structure-based or white-box testing is based on an identified structure of the software or the system.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 52,
    "imgUrl": "/public/images/2018/05/slide-0052-white.png",
    "knowledgeLevel": 4,
    "section": "4.4.1",
    "sectionHeading": "Statement Testing and Coverage",
    "syllabusText": "In component testing, statement coverage is the assessment of the percentage of executable statements that have been exercised by a test case suite. The statement testing technique derives test cases to execute specific statements, normally to increase statement coverage.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 53,
    "imgUrl": "/public/images/2018/05/slide-0053-white.png",
    "knowledgeLevel": 4,
    "section": "4.4.2",
    "sectionHeading": "Decision Testing and Coverage",
    "syllabusText": "Decision coverage, related to branch testing, is the assessment of the percentage of decision outcomes (e.g., the True and False options of an IF statement) that have been exercised by a test case suite. The decision testing technique derives test cases to execute specific decision outcomes. Branches originate from decision points in the code and show the transfer of control to different locations in the code.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 54,
    "imgUrl": "/public/images/2018/05/slide-0054-white.png",
    "knowledgeLevel": 1,
    "section": "4.4.3",
    "sectionHeading": "Other Structure-based Techniques",
    "syllabusText": "There are stronger levels of structural coverage beyond decision coverage, for example, condition coverage and multiple condition coverage.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 55,
    "imgUrl": "/public/images/2018/05/slide-0055-white.png",
    "knowledgeLevel": 2,
    "section": "4.5",
    "sectionHeading": "Experience-based Techniques",
    "syllabusText": "Experience-based testing is where tests are derived from the tester’s skill and intuition and their experience with similar applications and technologies. ",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 56,
    "imgUrl": "/public/images/2018/05/slide-0056-white.png",
    "knowledgeLevel": 2,
    "section": "4.6",
    "sectionHeading": "Choosing Test Techniques",
    "syllabusText": "The choice of which test techniques to use depends on a number of factors, including the type of system, regulatory standards, customer or contractual requirements, level of risk, type of risk, test objective, documentation available, knowledge of the testers, time and budget, development life cycle, use case models and previous experience with types of defects found.",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 57,
    "imgUrl": "/public/images/2018/05/slide-0057-white.png",
    "knowledgeLevel": 3,
    "section": "5",
    "sectionHeading": "Test Management",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 58,
    "imgUrl": "/public/images/2018/05/slide-0058-white.png",
    "knowledgeLevel": 2,
    "section": "5.1",
    "sectionHeading": "Test Organization",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 59,
    "imgUrl": "/public/images/2018/05/slide-0059-white.png",
    "knowledgeLevel": 2,
    "section": "5.1.1",
    "sectionHeading": "Test Organization and Independence",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 60,
    "imgUrl": "/public/images/2018/05/slide-0060-white.png",
    "knowledgeLevel": 1,
    "section": "5.1.2",
    "sectionHeading": "Tasks of the Test Leader and Tester",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 61,
    "imgUrl": "/public/images/2018/05/slide-0061-white.png",
    "knowledgeLevel": 3,
    "section": "5.2",
    "sectionHeading": "Test Planning and Estimation",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 62,
    "imgUrl": "/public/images/2018/05/slide-0062-white.png",
    "knowledgeLevel": 2,
    "section": "5.2.1",
    "sectionHeading": "Test Planning",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 63,
    "imgUrl": "/public/images/2018/05/slide-0063-white.png",
    "knowledgeLevel": 3,
    "section": "5.2.2",
    "sectionHeading": "Test Planning Activities",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 64,
    "imgUrl": "/public/images/2018/05/slide-0064-white.png",
    "knowledgeLevel": 2,
    "section": "5.2.3",
    "sectionHeading": "Entry Criteria",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 65,
    "imgUrl": "/public/images/2018/05/slide-0065-white.png",
    "knowledgeLevel": 2,
    "section": "5.2.4",
    "sectionHeading": "Exit Criteria",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 66,
    "imgUrl": "/public/images/2018/05/slide-0066-white.png",
    "knowledgeLevel": 2,
    "section": "5.2.5",
    "sectionHeading": "Test Estimation",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 67,
    "imgUrl": "/public/images/2018/05/slide-0067-white.png",
    "knowledgeLevel": 2,
    "section": "5.2.6",
    "sectionHeading": "Test Strategy, Test Approach",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 68,
    "imgUrl": "/public/images/2018/05/slide-0068-white.png",
    "knowledgeLevel": 2,
    "section": "5.3",
    "sectionHeading": "Test Progress Monitoring and Control",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 69,
    "imgUrl": "/public/images/2018/05/slide-0069-white.png",
    "knowledgeLevel": 1,
    "section": "5.3",
    "sectionHeading": "Test Progress Monitoring",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 70,
    "imgUrl": "/public/images/2018/05/slide-0070-white.png",
    "knowledgeLevel": 2,
    "section": "5.3.2",
    "sectionHeading": "Test Reporting",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 71,
    "imgUrl": "/public/images/2018/05/slide-0071-white.png",
    "knowledgeLevel": 2,
    "section": "5.3.3",
    "sectionHeading": "Test Control",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 72,
    "imgUrl": "/public/images/2018/05/slide-0072-white.png",
    "knowledgeLevel": 2,
    "section": "5.4",
    "sectionHeading": "Configuration Management",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 73,
    "imgUrl": "/public/images/2018/05/slide-0073-white.png",
    "knowledgeLevel": 2,
    "section": "5.5",
    "sectionHeading": "Risk and Testing",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 74,
    "imgUrl": "/public/images/2018/05/slide-0074-white.png",
    "knowledgeLevel": 2,
    "section": "5.5.1",
    "sectionHeading": "Project Risks",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 75,
    "imgUrl": "/public/images/2018/05/slide-0075-white.png",
    "knowledgeLevel": 2,
    "section": "5.5.2",
    "sectionHeading": "Product Risks",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 76,
    "imgUrl": "/public/images/2018/05/slide-0076-white.png",
    "knowledgeLevel": 3,
    "section": "5.6",
    "sectionHeading": "Incident Management",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 77,
    "imgUrl": "/public/images/2018/05/slide-0077-white.png",
    "knowledgeLevel": 2,
    "section": "6",
    "sectionHeading": "Tool Support for Testing",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 78,
    "imgUrl": "/public/images/2018/05/slide-0078-white.png",
    "knowledgeLevel": 2,
    "section": "6.1",
    "sectionHeading": "Types of Test Tools",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 79,
    "imgUrl": "/public/images/2018/05/slide-0079-white.png",
    "knowledgeLevel": 2,
    "section": "6.1.1",
    "sectionHeading": "Tool Support for Testing",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 80,
    "imgUrl": "/public/images/2018/05/slide-0080-white.png",
    "knowledgeLevel": 2,
    "section": "6.1.2",
    "sectionHeading": "Test Tool Classification",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 81,
    "imgUrl": "/public/images/2018/05/slide-0081-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.3",
    "sectionHeading": "Tool Support for Management of Testing and Tests",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 82,
    "imgUrl": "/public/images/2018/05/slide-0082-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.4",
    "sectionHeading": "Tool Support for Static Testing",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 83,
    "imgUrl": "/public/images/2018/05/slide-0083-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.5",
    "sectionHeading": "Tool Support for Test Specification",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 84,
    "imgUrl": "/public/images/2018/05/slide-0084-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.6",
    "sectionHeading": "Tool Support for Test Execution and Logging",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 85,
    "imgUrl": "/public/images/2018/05/slide-0085-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.7",
    "sectionHeading": "Tool Support for Performance and Monitoring",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 86,
    "imgUrl": "/public/images/2018/05/slide-0086-white.png",
    "knowledgeLevel": 1,
    "section": "6.1.8",
    "sectionHeading": "Tool Support for Specific Testing Needs",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 87,
    "imgUrl": "/public/images/2018/05/slide-0087-white.png",
    "knowledgeLevel": 2,
    "section": "6.2",
    "sectionHeading": "Effective Use of Tools: Potential Benefits and Risks",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 88,
    "imgUrl": "/public/images/2018/05/slide-0088-white.png",
    "knowledgeLevel": 2,
    "section": "6.2.1",
    "sectionHeading": "Potential Benefits and Risks of Tool Support for Testing (for all tools)",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 89,
    "imgUrl": "/public/images/2018/05/slide-0089-white.png",
    "knowledgeLevel": 1,
    "section": "6.2.2",
    "sectionHeading": "Special Consideration for Some Types of Tools",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  },
  {
    "id": 90,
    "imgUrl": "/public/images/2018/05/slide-0090-white.png",
    "knowledgeLevel": 1,
    "section": "6.3",
    "sectionHeading": "Introducing a Tool into an Organization",
    "syllabusText": "",
    "fostSynopsis": "",
    "aostSynopsis": ""
  }
]
